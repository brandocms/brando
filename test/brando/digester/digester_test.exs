defmodule Brando.DigesterTest do
  use ExUnit.Case, async: true

  @output_path Path.join("tmp", "brando_digest")
  @hash_regex ~S"[a-fA-F\d]{32}"

  defmodule DigestTestCompressor do
    def compress_file(_file_path, _content), do: {:error, "test error"}
    def file_extensions, do: [".digest_test"]
  end

  setup do
    File.rm_rf!(@output_path)
    on_exit(fn -> File.rm_rf!(@output_path) end)
    :ok
  end

  describe "compile" do
    test "digests and compresses files" do
      test_path = "test/fixtures/digest_test"
      output_path = @output_path

      # Create test fixtures
      File.mkdir_p!(Path.join(test_path, "css"))
      File.write!(Path.join(test_path, "app.js"), "console.log('test');")
      File.write!(Path.join(test_path, "css/app.css"), ".foo { background: url(/images/test.png); }")
      File.write!(Path.join(test_path, "test.png"), "fake png content")

      # Run the digester
      :ok = Brando.Digester.compile(test_path, output_path, true)

      # Get list of output files
      output_files = assets_files(@output_path)

      # Check for original files
      assert "app.js" in output_files
      assert "css/app.css" in output_files
      assert "test.png" in output_files

      # Check for compressed files
      assert Enum.any?(output_files, &String.match?(&1, ~r/app\.js\.gz$/))
      assert Enum.any?(output_files, &String.match?(&1, ~r/css\/app\.css\.gz$/))

      # Check for digested PNG
      assert Enum.any?(output_files, &String.match?(&1, ~r/test-#{@hash_regex}\.png$/))

      # Cache manifest should be created
      assert "cache_manifest.json" in output_files

      manifest = Path.join(@output_path, "cache_manifest.json") |> File.read!()

      # Parse the manifest JSON for easier testing
      parsed_manifest = Jason.decode!(manifest)

      # Test the structure and fixed values
      assert parsed_manifest["!comment!"] ==
               "This file was auto-generated by `mix brando.digest`. Remove it and all generated artefacts with `mix brando.digest.clean --all`"

      assert parsed_manifest["version"] == 1

      # Test the latest mappings
      assert parsed_manifest["latest"]["app.js"] == "app.js"
      assert parsed_manifest["latest"]["css/app.css"] == "css/app.css"
      assert parsed_manifest["latest"]["test.png"] =~ ~r/test-#{@hash_regex}\.png$/

      # Test the digests information without mtime
      assert parsed_manifest["digests"]["app.js"]["size"] == 20
      assert parsed_manifest["digests"]["app.js"]["digest"] == "324e63777cae0113d708633836c9cb18"
      assert parsed_manifest["digests"]["app.js"]["logical_path"] == "app.js"

      assert parsed_manifest["digests"]["css/app.css"]["size"] == 43
      assert parsed_manifest["digests"]["css/app.css"]["digest"] == "1cad97c96fe8167325c89e80986ddd13"
      assert parsed_manifest["digests"]["css/app.css"]["logical_path"] == "css/app.css"

      # Test the digested PNG entry
      png_key = Enum.find(Map.keys(parsed_manifest["digests"]), &String.match?(&1, ~r/test-#{@hash_regex}\.png$/))
      assert parsed_manifest["digests"][png_key]["size"] == 16
      assert parsed_manifest["digests"][png_key]["digest"] == "107e448b716ee8bbb6d9579c4b88a9e9"
      assert parsed_manifest["digests"][png_key]["logical_path"] == "test.png"

      # Verify that mtime exists but don't check its value
      assert Map.has_key?(parsed_manifest["digests"]["app.js"], "mtime")
      assert Map.has_key?(parsed_manifest["digests"]["css/app.css"], "mtime")
      assert Map.has_key?(parsed_manifest["digests"][png_key], "mtime")
    after
      # Clean up test fixtures
      File.rm_rf!("test/fixtures/digest_test")
    end

    test "handles nested directories" do
      test_path = "test/fixtures/nested_test"
      output_path = @output_path

      # Create test fixtures with nested directories
      File.mkdir_p!(Path.join([test_path, "images", "icons"]))
      File.write!(Path.join([test_path, "images", "icons", "icon.png"]), "fake icon content")

      # Run the digester
      :ok = Brando.Digester.compile(test_path, output_path, true)

      # Get list of output files
      output_files = assets_files(@output_path)

      # Check for original files
      assert "images/icons/icon.png" in output_files

      # Check for digested files
      assert Enum.any?(output_files, &String.match?(&1, ~r/images\/icons\/icon-#{@hash_regex}\.png$/))
    after
      # Clean up test fixtures
      File.rm_rf!("test/fixtures/nested_test")
    end

    test "fails when the given path is invalid" do
      assert {:error, :invalid_path} = Brando.Digester.compile("nonexistent_path", @output_path, true)
    end
  end

  describe "digested_contents" do
    test "digests references in CSS stylesheets" do
      test_path = "test/fixtures/css_test"
      File.mkdir_p!(test_path)

      css_content = """
      .foo { background: url(/images/test.png); }
      .bar { background: url('../images/icon.png'); }
      .baz { background: url('http://example.com/image.png'); }
      """

      File.mkdir_p!(Path.join([test_path, "css"]))
      File.mkdir_p!(Path.join([test_path, "images"]))
      File.write!(Path.join([test_path, "images", "test.png"]), "fake png content")
      File.write!(Path.join([test_path, "images", "icon.png"]), "fake icon content")
      File.write!(Path.join([test_path, "css", "app.css"]), css_content)

      # Run the compile to test the whole process
      :ok = Brando.Digester.compile(test_path, @output_path, true)

      # Get the digested CSS
      output_files = assets_files(@output_path)
      digested_css_file = Enum.find(output_files, &String.match?(&1, ~r/css\/app\.css$/))
      digested_css = Path.join(@output_path, digested_css_file) |> File.read!()

      # Check that URLs were properly digested
      assert digested_css =~ ~r/url\(\/images\/test-#{@hash_regex}\.png(\?vsn=d)?\)/
      assert digested_css =~ ~r/url\('\.\.\/images\/icon-#{@hash_regex}\.png(\?vsn=d)?'\)/
      assert digested_css =~ ~r/url\('http:\/\/example\.com\/image\.png'\)/
    after
      # Clean up test fixtures
      File.rm_rf!("test/fixtures/css_test")
    end
  end

  # Helper functions

  defp assets_files(path) do
    path
    |> Path.join("**/*")
    |> Path.wildcard()
    |> Enum.filter(&(!File.dir?(&1)))
    |> Enum.map(&Path.relative_to(&1, path))
  end
end
