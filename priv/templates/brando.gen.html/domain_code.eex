@doc """
List all <%= plural %>
"""
@spec list_<%= plural %>(args :: map) :: {:ok, [<%= singular %>]}
def list_<%= plural %>(args \\ %{}) do
  query =
    args
    |> Enum.reduce(<%= alias %>, fn
      {_, nil}, query ->
        query

      {:order, order}, query ->
        query |> with_order(order)

      {:offset, offset}, query ->
        query |> offset(^offset)

      {:limit, limit}, query ->
        query |> limit(^limit)

      {:filter, filter}, query ->
        query |> with_filter(filter)<%= if status do %>

      {:status, status}, query ->
        query |> with_status(status)<% end %>
    end)

  query =
    from t in query<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>

  {:ok, Repo.all(query)}
end

defp with_order(query, {_, "status"}) do
  query
  |> order_by(fragment("status=0 DESC"))
  |> order_by(fragment("status=2 DESC"))
  |> order_by(fragment("status=1 DESC"))
  |> order_by(fragment("status=3 DESC"))
end

defp with_order(query, {dir, by}), do: query |> order_by({^dir, ^by})

defp with_filter(query, filter) do
  Enum.reduce(filter, query, fn
    {:<%= main_field %>, <%= main_field %>}, query ->
      from q in query, where: ilike(q.<%= main_field %>, ^"%#{<%= main_field %>}%")

    # {:featured, featured}, query ->
    #   from q in query, where: q.featured == ^featured
  end)
end<%= if status do %>

defp with_status(query, "all"), do: query
defp with_status(query, status), do: from q in query, where: q.status == ^status
<% end %>

@doc """
Get single <%= singular %>
"""
@spec get_<%= singular %>(keyword() | id) ::
        {:ok, <%= singular %>} | {:error, {:<%= singular %>, :not_found}}
def get_<%= singular %>(args) when is_list(args) do
  query = from t in <%= alias %><%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>
  case Repo.get_by(query, args) do
    nil -> {:error, {:<%= singular %>, :not_found}}
    <%= singular %> -> {:ok, <%= singular %>}
  end
end

def get_<%= singular %>(id) do
  query = from t in <%= alias %>, where: t.id == ^id<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>
  case Repo.one(query) do
    nil -> {:error, {:<%= singular %>, :not_found}}
    <%= singular %> -> {:ok, <%= singular %>}
  end
end

@doc """
Create new <%= singular %>
"""
@spec create_<%= singular %>(params, user | :system) ::
        {:ok, <%= singular %>} | {:error, Ecto.Changeset.t()}
def create_<%= singular %>(<%= singular %>_params, user \\ :system) do
  with changeset <- <%= alias %>.changeset(%<%= alias %>{}, <%= singular %>_params, user),
       {:ok, <%= singular %>} <- Repo.insert(changeset) do
    Brando.Datasource.update_datasource(<%= alias %>, <%= singular %>)
  else
    err -> err
  end
end

@doc """
Update existing <%= singular %>
"""
@spec update_<%= singular %>(id, params, user | :system) ::
        {:ok, <%= singular %>} | {:error, Ecto.Changeset.t()}
def update_<%= singular %>(<%= singular %>_id, <%= singular %>_params, user \\ :system) do
  with {:ok, <%= singular %>} <- get_<%= singular %>(<%= singular %>_id),
       changeset <- <%= alias %>.changeset(<%= singular %>, <%= singular %>_params, user),
       {:ok, <%= singular %>} <- Repo.update(changeset) do
    Brando.Datasource.update_datasource(<%= alias %>, <%= singular %>)
  else
    err -> err
  end
end

@doc """
Delete <%= singular %> by id
"""
@spec delete_<%= singular %>(id) ::
        {:ok, <%= singular %>}
def delete_<%= singular %>(id) do
  {:ok, <%= singular %>} = get_<%= singular %>(id)<%= if soft_delete do %>
  Repo.soft_delete(<%= singular %>)<% else %>
  Repo.delete(<%= singular %>)<% end %>
  <%= for {_v, k} <- gallery_fields || [] do %>
  Brando.Images.delete_series(<%= singular %>.<%= k %>)<% end %>
  Brando.Datasource.update_datasource(<%= alias %>, <%= singular %>)
end

<%= if gallery do %>
@doc """
Create an image series entry
"""
@spec create_image_series(id, user) ::
        {:ok, Brando.ImageSeries.t()} | {:error, Ecto.Changeset.t()}
def create_image_series(<%= singular %>_id, user) do
  {:ok, <%= singular %>} = get_<%= singular %>(<%= singular %>_id)
  {:ok, category} = Brando.Images.get_or_create_category_id_by_slug("<%= singular %>-gallery", user)

  data = %{
    name: <%= singular %>.name,
    slug: <%= singular %>.slug,
    image_category_id: category.id
  }

  with {:ok, series} <- Brando.Images.create_series(data, user) do
    cs = Ecto.Changeset.change(<%= singular %>, image_series_id: series.id)
    Repo.update(cs)

    {:ok, series}
  end
end
<% end %>