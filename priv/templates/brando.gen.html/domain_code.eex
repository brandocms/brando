@doc """
List all <%= plural %>
"""
@spec list_<%= plural %>(args :: map) :: {:ok, [<%= singular %>]}
def list_<%= plural %>(args \\ %{}) do
  query =
    args
    |> Enum.reduce(<%= alias %>, fn
      {_, nil}, query ->
        query
      {:order, {dir, by}}, query ->
        query |> order_by({^dir, ^by})
      {:offset, offset}, query ->
        query |> offset(^offset)
      {:limit, limit}, query ->
        query |> limit(^limit)
      {:filter, filter}, query ->
        query |> filter_with(filter)
    end)

  query =
    from t in query<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>

  {:ok, Repo.all(query)}
end

defp filter_with(query, filter) do
  Enum.reduce(filter, query, fn
    {:title, title}, query ->
      from q in query, where: ilike(q.title, ^"%#{title}%")

    # {:featured, featured}, query ->
    #   from q in query, where: q.featured == ^featured
  end)
end

@doc """
Get single <%= singular %>
"""
@spec get_<%= singular %>(keyword() | id) ::
        {:ok, <%= singular %>} | {:error, {:<%= singular %>, :not_found}}
def get_<%= singular %>(args) when is_list(args) do
  query = from t in <%= alias %><%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>
  case Repo.get_by(query, args) do
    nil -> {:error, {:<%= singular %>, :not_found}}
    <%= singular %> -> {:ok, <%= singular %>}
  end
end

def get_<%= singular %>(id) do
  query = from t in <%= alias %>, where: t.id == ^id<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>
  case Repo.one(query) do
    nil -> {:error, {:<%= singular %>, :not_found}}
    <%= singular %> -> {:ok, <%= singular %>}
  end
end

@doc """
Create new <%= singular %>
"""
@spec create_<%= singular %>(params, user | :system) ::
        {:ok, <%= singular %>} | {:error, Ecto.Changeset.t()}
def create_<%= singular %>(<%= singular %>_params, user \\ :system) do
  changeset = <%= alias %>.changeset(%<%= alias %>{}, <%= singular %>_params, user)
  Repo.insert(changeset)
end

@doc """
Update existing <%= singular %>
"""
@spec update_<%= singular %>(id, params, user | :system) ::
        {:ok, <%= singular %>} | {:error, Ecto.Changeset.t()}
def update_<%= singular %>(<%= singular %>_id, <%= singular %>_params, user \\ :system) do
  {:ok, <%= singular %>} = get_<%= singular %>(<%= singular %>_id)

  <%= singular %>
  |> <%= alias %>.changeset(<%= singular %>_params, user)
  |> Repo.update()
end

@doc """
Delete <%= singular %> by id
"""
@spec delete_<%= singular %>(id) ::
        {:ok, <%= singular %>}
def delete_<%= singular %>(id) do
  {:ok, <%= singular %>} = get_<%= singular %>(id)<%= if soft_delete do %>
  Repo.soft_delete(<%= singular %>)<% else %>
  Repo.delete(<%= singular %>)<% end %>
  <%= for {_v, k} <- gallery_fields || [] do %>
  Brando.Images.delete_series(<%= singular %>.<%= k %>)<% end %>
  {:ok, <%= singular %>}
end

<%= if gallery do %>
@doc """
Create an image series entry
"""
@spec create_image_series(id, user) ::
        {:ok, Brando.ImageSeries.t()} | {:error, Ecto.Changeset.t()}
def create_image_series(<%= singular %>_id, user) do
  {:ok, <%= singular %>} = get_<%= singular %>(<%= singular %>_id)
  {:ok, category} = Brando.Images.get_or_create_category_id_by_slug("<%= singular %>-gallery", user)

  data = %{
    name: <%= singular %>.name,
    slug: <%= singular %>.slug,
    image_category_id: category.id
  }

  with {:ok, series} <- Brando.Images.create_series(data, user) do
    cs = Ecto.Changeset.change(<%= singular %>, image_series_id: series.id)
    Repo.update(cs)

    {:ok, series}
  end
end
<% end %>