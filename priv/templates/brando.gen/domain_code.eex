query :list, <%= alias %> do
  fn query -> from t in query<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %> end
end

filters <%= alias %> do
  fn
    {:<%= main_field %>, <%= main_field %>}, query ->
      from q in query, where: ilike(q.<%= main_field %>, ^"%#{<%= main_field %>}%")
  end
end

query :single, <%= alias %>, do: fn query -> from t in query<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %> end

matches <%= alias %> do
  fn
    {:id, id}, query ->
      from t in query, where: t.id == ^id

    {:<%= List.first(attrs) |> elem(0) %>, <%= List.first(attrs) |> elem(0) %>}, query ->
      from t in query, where: t.<%= List.first(attrs) |> elem(0) %> == ^<%= List.first(attrs) |> elem(0) %><%= if Keyword.get(attrs, :slug) do %>

    {:slug, slug}, query ->
      from t in query, where: t.slug == ^slug<% end %>
  end
end

@doc """
Get single <%= singular %>
"""
@spec get_<%= singular %>(keyword() | id) ::
        {:ok, <%= singular %>} | {:error, {:<%= singular %>, :not_found}}
def get_<%= singular %>(args) when is_list(args) do
  query = from t in <%= alias %><%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>
  case Repo.get_by(query, args) do
    nil -> {:error, {:<%= singular %>, :not_found}}
    <%= singular %> -> {:ok, <%= singular %>}
  end
end

def get_<%= singular %>(id) do
  query = from t in <%= alias %>, where: t.id == ^id<%= if soft_delete do %>, where: is_nil(t.deleted_at)<% end %>
  case Repo.one(query) do
    nil -> {:error, {:<%= singular %>, :not_found}}
    <%= singular %> -> {:ok, <%= singular %>}
  end
end

@doc """
Create new <%= singular %>
"""
@spec create_<%= singular %>(params, user | :system) ::
        {:ok, <%= singular %>} | {:error, Ecto.Changeset.t()}
def create_<%= singular %>(<%= singular %>_params, user \\ :system) do
  with changeset <- <%= alias %>.changeset(%<%= alias %>{}, <%= singular %>_params, user),
       {:ok, <%= singular %>} <- Repo.insert(changeset) do
    Brando.Datasource.update_datasource(<%= alias %>, <%= singular %>)
  else
    err -> err
  end
end

@doc """
Update existing <%= singular %>
"""
@spec update_<%= singular %>(id, params, user | :system) ::
        {:ok, <%= singular %>} | {:error, Ecto.Changeset.t()}
def update_<%= singular %>(<%= singular %>_id, <%= singular %>_params, user \\ :system) do
  with {:ok, <%= singular %>} <- get_<%= singular %>(<%= singular %>_id),
       changeset <- <%= alias %>.changeset(<%= singular %>, <%= singular %>_params, user),
       {:ok, <%= singular %>} <- Repo.update(changeset) do
    Brando.Datasource.update_datasource(<%= alias %>, <%= singular %>)
  else
    err -> err
  end
end

@doc """
Delete <%= singular %> by id
"""
@spec delete_<%= singular %>(id) ::
        {:ok, <%= singular %>}
def delete_<%= singular %>(id) do
  {:ok, <%= singular %>} = get_<%= singular %>(id)<%= if soft_delete do %>
  Repo.soft_delete(<%= singular %>)<% else %>
  Repo.delete(<%= singular %>)<% end %>
  <%= for {_v, k} <- gallery_fields || [] do %>
  Brando.Images.delete_series(<%= singular %>.<%= k %>)<% end %>
  Brando.Datasource.update_datasource(<%= alias %>, <%= singular %>)
end

<%= if gallery do %>
@doc """
Create an image series entry
"""
@spec create_image_series(id, user) ::
        {:ok, Brando.ImageSeries.t()} | {:error, Ecto.Changeset.t()}
def create_image_series(<%= singular %>_id, user) do
  {:ok, <%= singular %>} = get_<%= singular %>(<%= singular %>_id)
  {:ok, category} = Brando.Images.get_or_create_category_id_by_slug("<%= singular %>-gallery", user)

  data = %{
    name: <%= singular %>.name,
    slug: <%= singular %>.slug,
    image_category_id: category.id
  }

  with {:ok, series} <- Brando.Images.create_series(data, user) do
    cs = Ecto.Changeset.change(<%= singular %>, image_series_id: series.id)
    Repo.update(cs)

    {:ok, series}
  end
end
<% end %>